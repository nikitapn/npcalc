/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcalculator"] = self["webpackChunkcalculator"] || []).push([["vendors-node_modules_svelte-materialify_dist_components_Slider_nouislider_min_js"],{

/***/ "./node_modules/svelte-materialify/dist/components/Slider/nouislider.min.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/svelte-materialify/dist/components/Slider/nouislider.min.js ***!
  \**********************************************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */\n/*! nouislider - 14.6.1 - 8/17/2020 */\n!(function (t) {\n   true\n    ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    : 0;\n})(function () {\n  'use strict';\n  var lt = '14.6.1';\n  function ut(t) {\n    t.parentElement.removeChild(t);\n  }\n  function a(t) {\n    return null != t;\n  }\n  function ct(t) {\n    t.preventDefault();\n  }\n  function o(t) {\n    return 'number' == typeof t && !isNaN(t) && isFinite(t);\n  }\n  function pt(t, e, r) {\n    0 < r &&\n      (ht(t, e),\n      setTimeout(function () {\n        mt(t, e);\n      }, r));\n  }\n  function ft(t) {\n    return Math.max(Math.min(t, 100), 0);\n  }\n  function dt(t) {\n    return Array.isArray(t) ? t : [t];\n  }\n  function e(t) {\n    var e = (t = String(t)).split('.');\n    return 1 < e.length ? e[1].length : 0;\n  }\n  function ht(t, e) {\n    t.classList && !/\\s/.test(e) ? t.classList.add(e) : (t.className += ' ' + e);\n  }\n  function mt(t, e) {\n    t.classList && !/\\s/.test(e)\n      ? t.classList.remove(e)\n      : (t.className = t.className.replace(\n          new RegExp('(^|\\\\b)' + e.split(' ').join('|') + '(\\\\b|$)', 'gi'),\n          ' ',\n        ));\n  }\n  function gt(t) {\n    var e = void 0 !== window.pageXOffset,\n      r = 'CSS1Compat' === (t.compatMode || '');\n    return {\n      x: e ? window.pageXOffset : r ? t.documentElement.scrollLeft : t.body.scrollLeft,\n      y: e ? window.pageYOffset : r ? t.documentElement.scrollTop : t.body.scrollTop,\n    };\n  }\n  function c(t, e) {\n    return 100 / (e - t);\n  }\n  function p(t, e, r) {\n    return (100 * e) / (t[r + 1] - t[r]);\n  }\n  function f(t, e) {\n    for (var r = 1; t >= e[r]; ) r += 1;\n    return r;\n  }\n  function r(t, e, r) {\n    if (r >= t.slice(-1)[0]) return 100;\n    var n,\n      i,\n      o = f(r, t),\n      s = t[o - 1],\n      a = t[o],\n      l = e[o - 1],\n      u = e[o];\n    return (\n      l +\n      ((i = r), p((n = [s, a]), n[0] < 0 ? i + Math.abs(n[0]) : i - n[0], 0) / c(l, u))\n    );\n  }\n  function n(t, e, r, n) {\n    if (100 === n) return n;\n    var i,\n      o,\n      s = f(n, t),\n      a = t[s - 1],\n      l = t[s];\n    return r\n      ? (l - a) / 2 < n - a\n        ? l\n        : a\n      : e[s - 1]\n      ? t[s - 1] + ((i = n - t[s - 1]), (o = e[s - 1]), Math.round(i / o) * o)\n      : n;\n  }\n  function s(t, e, r) {\n    var n;\n    if (('number' == typeof e && (e = [e]), !Array.isArray(e)))\n      throw new Error('noUiSlider (' + lt + \"): 'range' contains invalid value.\");\n    if (!o((n = 'min' === t ? 0 : 'max' === t ? 100 : parseFloat(t))) || !o(e[0]))\n      throw new Error('noUiSlider (' + lt + \"): 'range' value isn't numeric.\");\n    r.xPct.push(n),\n      r.xVal.push(e[0]),\n      n ? r.xSteps.push(!isNaN(e[1]) && e[1]) : isNaN(e[1]) || (r.xSteps[0] = e[1]),\n      r.xHighestCompleteStep.push(0);\n  }\n  function l(t, e, r) {\n    if (e)\n      if (r.xVal[t] !== r.xVal[t + 1]) {\n        r.xSteps[t] = p([r.xVal[t], r.xVal[t + 1]], e, 0) / c(r.xPct[t], r.xPct[t + 1]);\n        var n = (r.xVal[t + 1] - r.xVal[t]) / r.xNumSteps[t],\n          i = Math.ceil(Number(n.toFixed(3)) - 1),\n          o = r.xVal[t] + r.xNumSteps[t] * i;\n        r.xHighestCompleteStep[t] = o;\n      } else r.xSteps[t] = r.xHighestCompleteStep[t] = r.xVal[t];\n  }\n  function i(t, e, r) {\n    var n;\n    (this.xPct = []),\n      (this.xVal = []),\n      (this.xSteps = [r || !1]),\n      (this.xNumSteps = [!1]),\n      (this.xHighestCompleteStep = []),\n      (this.snap = e);\n    var i = [];\n    for (n in t) t.hasOwnProperty(n) && i.push([t[n], n]);\n    for (\n      i.length && 'object' == typeof i[0][0]\n        ? i.sort(function (t, e) {\n            return t[0][0] - e[0][0];\n          })\n        : i.sort(function (t, e) {\n            return t[0] - e[0];\n          }),\n        n = 0;\n      n < i.length;\n      n++\n    )\n      s(i[n][1], i[n][0], this);\n    for (this.xNumSteps = this.xSteps.slice(0), n = 0; n < this.xNumSteps.length; n++)\n      l(n, this.xNumSteps[n], this);\n  }\n  (i.prototype.getDistance = function (t) {\n    var e,\n      r = [];\n    for (e = 0; e < this.xNumSteps.length - 1; e++) {\n      var n = this.xNumSteps[e];\n      if (n && (t / n) % 1 != 0)\n        throw new Error(\n          'noUiSlider (' +\n            lt +\n            \"): 'limit', 'margin' and 'padding' of \" +\n            this.xPct[e] +\n            '% range must be divisible by step.',\n        );\n      r[e] = p(this.xVal, t, e);\n    }\n    return r;\n  }),\n    (i.prototype.getAbsoluteDistance = function (t, e, r) {\n      var n,\n        i = 0;\n      if (t < this.xPct[this.xPct.length - 1]) for (; t > this.xPct[i + 1]; ) i++;\n      else t === this.xPct[this.xPct.length - 1] && (i = this.xPct.length - 2);\n      r || t !== this.xPct[i + 1] || i++;\n      var o = 1,\n        s = e[i],\n        a = 0,\n        l = 0,\n        u = 0,\n        c = 0;\n      for (\n        n = r\n          ? (t - this.xPct[i]) / (this.xPct[i + 1] - this.xPct[i])\n          : (this.xPct[i + 1] - t) / (this.xPct[i + 1] - this.xPct[i]);\n        0 < s;\n\n      )\n        (a = this.xPct[i + 1 + c] - this.xPct[i + c]),\n          100 < e[i + c] * o + 100 - 100 * n\n            ? ((l = a * n), (o = (s - 100 * n) / e[i + c]), (n = 1))\n            : ((l = ((e[i + c] * a) / 100) * o), (o = 0)),\n          r\n            ? ((u -= l), 1 <= this.xPct.length + c && c--)\n            : ((u += l), 1 <= this.xPct.length - c && c++),\n          (s = e[i + c] * o);\n      return t + u;\n    }),\n    (i.prototype.toStepping = function (t) {\n      return (t = r(this.xVal, this.xPct, t));\n    }),\n    (i.prototype.fromStepping = function (t) {\n      return (function (t, e, r) {\n        if (100 <= r) return t.slice(-1)[0];\n        var n,\n          i = f(r, e),\n          o = t[i - 1],\n          s = t[i],\n          a = e[i - 1],\n          l = e[i];\n        return (n = [o, s]), ((r - a) * c(a, l) * (n[1] - n[0])) / 100 + n[0];\n      })(this.xVal, this.xPct, t);\n    }),\n    (i.prototype.getStep = function (t) {\n      return (t = n(this.xPct, this.xSteps, this.snap, t));\n    }),\n    (i.prototype.getDefaultStep = function (t, e, r) {\n      var n = f(t, this.xPct);\n      return (\n        (100 === t || (e && t === this.xPct[n - 1])) && (n = Math.max(n - 1, 1)),\n        (this.xVal[n] - this.xVal[n - 1]) / r\n      );\n    }),\n    (i.prototype.getNearbySteps = function (t) {\n      var e = f(t, this.xPct);\n      return {\n        stepBefore: {\n          startValue: this.xVal[e - 2],\n          step: this.xNumSteps[e - 2],\n          highestStep: this.xHighestCompleteStep[e - 2],\n        },\n        thisStep: {\n          startValue: this.xVal[e - 1],\n          step: this.xNumSteps[e - 1],\n          highestStep: this.xHighestCompleteStep[e - 1],\n        },\n        stepAfter: {\n          startValue: this.xVal[e],\n          step: this.xNumSteps[e],\n          highestStep: this.xHighestCompleteStep[e],\n        },\n      };\n    }),\n    (i.prototype.countStepDecimals = function () {\n      var t = this.xNumSteps.map(e);\n      return Math.max.apply(null, t);\n    }),\n    (i.prototype.convert = function (t) {\n      return this.getStep(this.toStepping(t));\n    });\n  var u = {\n      to: function (t) {\n        return void 0 !== t && t.toFixed(2);\n      },\n      from: Number,\n    },\n    d = {\n      target: 'target',\n      base: 'base',\n      origin: 'origin',\n      handle: 'handle',\n      handleLower: 'handle-lower',\n      handleUpper: 'handle-upper',\n      touchArea: 'touch-area',\n      horizontal: 'horizontal',\n      vertical: 'vertical',\n      background: 'background',\n      connect: 'connect',\n      connects: 'connects',\n      ltr: 'ltr',\n      rtl: 'rtl',\n      textDirectionLtr: 'txt-dir-ltr',\n      textDirectionRtl: 'txt-dir-rtl',\n      draggable: 'draggable',\n      drag: 'state-drag',\n      tap: 'state-tap',\n      active: 'active',\n      tooltip: 'tooltip',\n      pips: 'pips',\n      pipsHorizontal: 'pips-horizontal',\n      pipsVertical: 'pips-vertical',\n      marker: 'marker',\n      markerHorizontal: 'marker-horizontal',\n      markerVertical: 'marker-vertical',\n      markerNormal: 'marker-normal',\n      markerLarge: 'marker-large',\n      markerSub: 'marker-sub',\n      value: 'value',\n      valueHorizontal: 'value-horizontal',\n      valueVertical: 'value-vertical',\n      valueNormal: 'value-normal',\n      valueLarge: 'value-large',\n      valueSub: 'value-sub',\n    };\n  function h(t) {\n    if (\n      'object' == typeof (e = t) &&\n      'function' == typeof e.to &&\n      'function' == typeof e.from\n    )\n      return !0;\n    var e;\n    throw new Error(\n      'noUiSlider (' + lt + \"): 'format' requires 'to' and 'from' methods.\",\n    );\n  }\n  function m(t, e) {\n    if (!o(e)) throw new Error('noUiSlider (' + lt + \"): 'step' is not numeric.\");\n    t.singleStep = e;\n  }\n  function g(t, e) {\n    if (!o(e))\n      throw new Error(\n        'noUiSlider (' + lt + \"): 'keyboardPageMultiplier' is not numeric.\",\n      );\n    t.keyboardPageMultiplier = e;\n  }\n  function v(t, e) {\n    if (!o(e))\n      throw new Error('noUiSlider (' + lt + \"): 'keyboardDefaultStep' is not numeric.\");\n    t.keyboardDefaultStep = e;\n  }\n  function b(t, e) {\n    if ('object' != typeof e || Array.isArray(e))\n      throw new Error('noUiSlider (' + lt + \"): 'range' is not an object.\");\n    if (void 0 === e.min || void 0 === e.max)\n      throw new Error('noUiSlider (' + lt + \"): Missing 'min' or 'max' in 'range'.\");\n    if (e.min === e.max)\n      throw new Error(\n        'noUiSlider (' + lt + \"): 'range' 'min' and 'max' cannot be equal.\",\n      );\n    t.spectrum = new i(e, t.snap, t.singleStep);\n  }\n  function x(t, e) {\n    if (((e = dt(e)), !Array.isArray(e) || !e.length))\n      throw new Error('noUiSlider (' + lt + \"): 'start' option is incorrect.\");\n    (t.handles = e.length), (t.start = e);\n  }\n  function S(t, e) {\n    if ('boolean' != typeof (t.snap = e))\n      throw new Error('noUiSlider (' + lt + \"): 'snap' option must be a boolean.\");\n  }\n  function w(t, e) {\n    if ('boolean' != typeof (t.animate = e))\n      throw new Error('noUiSlider (' + lt + \"): 'animate' option must be a boolean.\");\n  }\n  function y(t, e) {\n    if ('number' != typeof (t.animationDuration = e))\n      throw new Error(\n        'noUiSlider (' + lt + \"): 'animationDuration' option must be a number.\",\n      );\n  }\n  function E(t, e) {\n    var r,\n      n = [!1];\n    if (\n      ('lower' === e ? (e = [!0, !1]) : 'upper' === e && (e = [!1, !0]),\n      !0 === e || !1 === e)\n    ) {\n      for (r = 1; r < t.handles; r++) n.push(e);\n      n.push(!1);\n    } else {\n      if (!Array.isArray(e) || !e.length || e.length !== t.handles + 1)\n        throw new Error(\n          'noUiSlider (' + lt + \"): 'connect' option doesn't match handle count.\",\n        );\n      n = e;\n    }\n    t.connect = n;\n  }\n  function C(t, e) {\n    switch (e) {\n      case 'horizontal':\n        t.ort = 0;\n        break;\n      case 'vertical':\n        t.ort = 1;\n        break;\n      default:\n        throw new Error('noUiSlider (' + lt + \"): 'orientation' option is invalid.\");\n    }\n  }\n  function P(t, e) {\n    if (!o(e))\n      throw new Error('noUiSlider (' + lt + \"): 'margin' option must be numeric.\");\n    0 !== e && (t.margin = t.spectrum.getDistance(e));\n  }\n  function N(t, e) {\n    if (!o(e))\n      throw new Error('noUiSlider (' + lt + \"): 'limit' option must be numeric.\");\n    if (((t.limit = t.spectrum.getDistance(e)), !t.limit || t.handles < 2))\n      throw new Error(\n        'noUiSlider (' +\n          lt +\n          \"): 'limit' option is only supported on linear sliders with 2 or more handles.\",\n      );\n  }\n  function k(t, e) {\n    var r;\n    if (!o(e) && !Array.isArray(e))\n      throw new Error(\n        'noUiSlider (' +\n          lt +\n          \"): 'padding' option must be numeric or array of exactly 2 numbers.\",\n      );\n    if (Array.isArray(e) && 2 !== e.length && !o(e[0]) && !o(e[1]))\n      throw new Error(\n        'noUiSlider (' +\n          lt +\n          \"): 'padding' option must be numeric or array of exactly 2 numbers.\",\n      );\n    if (0 !== e) {\n      for (\n        Array.isArray(e) || (e = [e, e]),\n          t.padding = [t.spectrum.getDistance(e[0]), t.spectrum.getDistance(e[1])],\n          r = 0;\n        r < t.spectrum.xNumSteps.length - 1;\n        r++\n      )\n        if (t.padding[0][r] < 0 || t.padding[1][r] < 0)\n          throw new Error(\n            'noUiSlider (' + lt + \"): 'padding' option must be a positive number(s).\",\n          );\n      var n = e[0] + e[1],\n        i = t.spectrum.xVal[0];\n      if (1 < n / (t.spectrum.xVal[t.spectrum.xVal.length - 1] - i))\n        throw new Error(\n          'noUiSlider (' + lt + \"): 'padding' option must not exceed 100% of the range.\",\n        );\n    }\n  }\n  function U(t, e) {\n    switch (e) {\n      case 'ltr':\n        t.dir = 0;\n        break;\n      case 'rtl':\n        t.dir = 1;\n        break;\n      default:\n        throw new Error(\n          'noUiSlider (' + lt + \"): 'direction' option was not recognized.\",\n        );\n    }\n  }\n  function A(t, e) {\n    if ('string' != typeof e)\n      throw new Error(\n        'noUiSlider (' + lt + \"): 'behaviour' must be a string containing options.\",\n      );\n    var r = 0 <= e.indexOf('tap'),\n      n = 0 <= e.indexOf('drag'),\n      i = 0 <= e.indexOf('fixed'),\n      o = 0 <= e.indexOf('snap'),\n      s = 0 <= e.indexOf('hover'),\n      a = 0 <= e.indexOf('unconstrained');\n    if (i) {\n      if (2 !== t.handles)\n        throw new Error(\n          'noUiSlider (' + lt + \"): 'fixed' behaviour must be used with 2 handles\",\n        );\n      P(t, t.start[1] - t.start[0]);\n    }\n    if (a && (t.margin || t.limit))\n      throw new Error(\n        'noUiSlider (' +\n          lt +\n          \"): 'unconstrained' behaviour cannot be used with margin or limit\",\n      );\n    t.events = { tap: r || o, drag: n, fixed: i, snap: o, hover: s, unconstrained: a };\n  }\n  function V(t, e) {\n    if (!1 !== e)\n      if (!0 === e) {\n        t.tooltips = [];\n        for (var r = 0; r < t.handles; r++) t.tooltips.push(!0);\n      } else {\n        if (((t.tooltips = dt(e)), t.tooltips.length !== t.handles))\n          throw new Error(\n            'noUiSlider (' + lt + '): must pass a formatter for all handles.',\n          );\n        t.tooltips.forEach(function (t) {\n          if (\n            'boolean' != typeof t &&\n            ('object' != typeof t || 'function' != typeof t.to)\n          )\n            throw new Error(\n              'noUiSlider (' +\n                lt +\n                \"): 'tooltips' must be passed a formatter or 'false'.\",\n            );\n        });\n      }\n  }\n  function D(t, e) {\n    h((t.ariaFormat = e));\n  }\n  function M(t, e) {\n    h((t.format = e));\n  }\n  function O(t, e) {\n    if ('boolean' != typeof (t.keyboardSupport = e))\n      throw new Error(\n        'noUiSlider (' + lt + \"): 'keyboardSupport' option must be a boolean.\",\n      );\n  }\n  function L(t, e) {\n    t.documentElement = e;\n  }\n  function z(t, e) {\n    if ('string' != typeof e && !1 !== e)\n      throw new Error(\n        'noUiSlider (' + lt + \"): 'cssPrefix' must be a string or `false`.\",\n      );\n    t.cssPrefix = e;\n  }\n  function H(t, e) {\n    if ('object' != typeof e)\n      throw new Error('noUiSlider (' + lt + \"): 'cssClasses' must be an object.\");\n    if ('string' == typeof t.cssPrefix)\n      for (var r in ((t.cssClasses = {}), e))\n        e.hasOwnProperty(r) && (t.cssClasses[r] = t.cssPrefix + e[r]);\n    else t.cssClasses = e;\n  }\n  function vt(e) {\n    var r = {\n        margin: 0,\n        limit: 0,\n        padding: 0,\n        animate: !0,\n        animationDuration: 300,\n        ariaFormat: u,\n        format: u,\n      },\n      n = {\n        step: { r: !1, t: m },\n        keyboardPageMultiplier: { r: !1, t: g },\n        keyboardDefaultStep: { r: !1, t: v },\n        start: { r: !0, t: x },\n        connect: { r: !0, t: E },\n        direction: { r: !0, t: U },\n        snap: { r: !1, t: S },\n        animate: { r: !1, t: w },\n        animationDuration: { r: !1, t: y },\n        range: { r: !0, t: b },\n        orientation: { r: !1, t: C },\n        margin: { r: !1, t: P },\n        limit: { r: !1, t: N },\n        padding: { r: !1, t: k },\n        behaviour: { r: !0, t: A },\n        ariaFormat: { r: !1, t: D },\n        format: { r: !1, t: M },\n        tooltips: { r: !1, t: V },\n        keyboardSupport: { r: !0, t: O },\n        documentElement: { r: !1, t: L },\n        cssPrefix: { r: !0, t: z },\n        cssClasses: { r: !0, t: H },\n      },\n      i = {\n        connect: !1,\n        direction: 'ltr',\n        behaviour: 'tap',\n        orientation: 'horizontal',\n        keyboardSupport: !0,\n        cssPrefix: 'noUi-',\n        cssClasses: d,\n        keyboardPageMultiplier: 5,\n        keyboardDefaultStep: 10,\n      };\n    e.format && !e.ariaFormat && (e.ariaFormat = e.format),\n      Object.keys(n).forEach(function (t) {\n        if (!a(e[t]) && void 0 === i[t]) {\n          if (n[t].r)\n            throw new Error('noUiSlider (' + lt + \"): '\" + t + \"' is required.\");\n          return !0;\n        }\n        n[t].t(r, a(e[t]) ? e[t] : i[t]);\n      }),\n      (r.pips = e.pips);\n    var t = document.createElement('div'),\n      o = void 0 !== t.style.msTransform,\n      s = void 0 !== t.style.transform;\n    r.transformRule = s ? 'transform' : o ? 'msTransform' : 'webkitTransform';\n    return (\n      (r.style = [\n        ['left', 'top'],\n        ['right', 'bottom'],\n      ][r.dir][r.ort]),\n      r\n    );\n  }\n  function j(t, b, o) {\n    var l,\n      u,\n      s,\n      c,\n      i,\n      a,\n      e,\n      p,\n      f = window.navigator.pointerEnabled\n        ? { start: 'pointerdown', move: 'pointermove', end: 'pointerup' }\n        : window.navigator.msPointerEnabled\n        ? { start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp' }\n        : {\n            start: 'mousedown touchstart',\n            move: 'mousemove touchmove',\n            end: 'mouseup touchend',\n          },\n      d =\n        window.CSS &&\n        CSS.supports &&\n        CSS.supports('touch-action', 'none') &&\n        (function () {\n          var t = !1;\n          try {\n            var e = Object.defineProperty({}, 'passive', {\n              get: function () {\n                t = !0;\n              },\n            });\n            window.addEventListener('test', null, e);\n          } catch (t) {}\n          return t;\n        })(),\n      h = t,\n      y = b.spectrum,\n      x = [],\n      S = [],\n      m = [],\n      g = 0,\n      v = {},\n      w = t.ownerDocument,\n      E = b.documentElement || w.documentElement,\n      C = w.body,\n      P = -1,\n      N = 0,\n      k = 1,\n      U = 2,\n      A = 'rtl' === w.dir || 1 === b.ort ? 0 : 100;\n    function V(t, e) {\n      var r = w.createElement('div');\n      return e && ht(r, e), t.appendChild(r), r;\n    }\n    function D(t, e) {\n      var r = V(t, b.cssClasses.origin),\n        n = V(r, b.cssClasses.handle);\n      return (\n        V(n, b.cssClasses.touchArea),\n        n.setAttribute('data-handle', e),\n        b.keyboardSupport &&\n          (n.setAttribute('tabindex', '0'),\n          n.addEventListener('keydown', function (t) {\n            return (function (t, e) {\n              if (O() || L(e)) return !1;\n              var r = ['Left', 'Right'],\n                n = ['Down', 'Up'],\n                i = ['PageDown', 'PageUp'],\n                o = ['Home', 'End'];\n              b.dir && !b.ort\n                ? r.reverse()\n                : b.ort && !b.dir && (n.reverse(), i.reverse());\n              var s,\n                a = t.key.replace('Arrow', ''),\n                l = a === i[0],\n                u = a === i[1],\n                c = a === n[0] || a === r[0] || l,\n                p = a === n[1] || a === r[1] || u,\n                f = a === o[0],\n                d = a === o[1];\n              if (!(c || p || f || d)) return !0;\n              if ((t.preventDefault(), p || c)) {\n                var h = b.keyboardPageMultiplier,\n                  m = c ? 0 : 1,\n                  g = at(e),\n                  v = g[m];\n                if (null === v) return !1;\n                !1 === v && (v = y.getDefaultStep(S[e], c, b.keyboardDefaultStep)),\n                  (u || l) && (v *= h),\n                  (v = Math.max(v, 1e-7)),\n                  (v *= c ? -1 : 1),\n                  (s = x[e] + v);\n              } else s = d ? b.spectrum.xVal[b.spectrum.xVal.length - 1] : b.spectrum.xVal[0];\n              return (\n                rt(e, y.toStepping(s), !0, !0),\n                J('slide', e),\n                J('update', e),\n                J('change', e),\n                J('set', e),\n                !1\n              );\n            })(t, e);\n          })),\n        n.setAttribute('role', 'slider'),\n        n.setAttribute('aria-orientation', b.ort ? 'vertical' : 'horizontal'),\n        0 === e\n          ? ht(n, b.cssClasses.handleLower)\n          : e === b.handles - 1 && ht(n, b.cssClasses.handleUpper),\n        r\n      );\n    }\n    function M(t, e) {\n      return !!e && V(t, b.cssClasses.connect);\n    }\n    function r(t, e) {\n      return !!b.tooltips[e] && V(t.firstChild, b.cssClasses.tooltip);\n    }\n    function O() {\n      return h.hasAttribute('disabled');\n    }\n    function L(t) {\n      return u[t].hasAttribute('disabled');\n    }\n    function z() {\n      i &&\n        (G('update.tooltips'),\n        i.forEach(function (t) {\n          t && ut(t);\n        }),\n        (i = null));\n    }\n    function H() {\n      z(),\n        (i = u.map(r)),\n        $('update.tooltips', function (t, e, r) {\n          if (i[e]) {\n            var n = t[e];\n            !0 !== b.tooltips[e] && (n = b.tooltips[e].to(r[e])), (i[e].innerHTML = n);\n          }\n        });\n    }\n    function j(e, i, o) {\n      var s = w.createElement('div'),\n        a = [];\n      (a[N] = b.cssClasses.valueNormal),\n        (a[k] = b.cssClasses.valueLarge),\n        (a[U] = b.cssClasses.valueSub);\n      var l = [];\n      (l[N] = b.cssClasses.markerNormal),\n        (l[k] = b.cssClasses.markerLarge),\n        (l[U] = b.cssClasses.markerSub);\n      var u = [b.cssClasses.valueHorizontal, b.cssClasses.valueVertical],\n        c = [b.cssClasses.markerHorizontal, b.cssClasses.markerVertical];\n      function p(t, e) {\n        var r = e === b.cssClasses.value,\n          n = r ? a : l;\n        return e + ' ' + (r ? u : c)[b.ort] + ' ' + n[t];\n      }\n      return (\n        ht(s, b.cssClasses.pips),\n        ht(s, 0 === b.ort ? b.cssClasses.pipsHorizontal : b.cssClasses.pipsVertical),\n        Object.keys(e).forEach(function (t) {\n          !(function (t, e, r) {\n            if ((r = i ? i(e, r) : r) !== P) {\n              var n = V(s, !1);\n              (n.className = p(r, b.cssClasses.marker)),\n                (n.style[b.style] = t + '%'),\n                N < r &&\n                  (((n = V(s, !1)).className = p(r, b.cssClasses.value)),\n                  n.setAttribute('data-value', e),\n                  (n.style[b.style] = t + '%'),\n                  (n.innerHTML = o.to(e)));\n            }\n          })(t, e[t][0], e[t][1]);\n        }),\n        s\n      );\n    }\n    function F() {\n      c && (ut(c), (c = null));\n    }\n    function R(t) {\n      F();\n      var m,\n        g,\n        v,\n        b,\n        e,\n        r,\n        x,\n        S,\n        w,\n        n = t.mode,\n        i = t.density || 1,\n        o = t.filter || !1,\n        s = (function (t, e, r) {\n          if ('range' === t || 'steps' === t) return y.xVal;\n          if ('count' === t) {\n            if (e < 2)\n              throw new Error(\n                'noUiSlider (' + lt + \"): 'values' (>= 2) required for mode 'count'.\",\n              );\n            var n = e - 1,\n              i = 100 / n;\n            for (e = []; n--; ) e[n] = n * i;\n            e.push(100), (t = 'positions');\n          }\n          return 'positions' === t\n            ? e.map(function (t) {\n                return y.fromStepping(r ? y.getStep(t) : t);\n              })\n            : 'values' === t\n            ? r\n              ? e.map(function (t) {\n                  return y.fromStepping(y.getStep(y.toStepping(t)));\n                })\n              : e\n            : void 0;\n        })(n, t.values || !1, t.stepped || !1),\n        a =\n          ((m = i),\n          (g = n),\n          (v = s),\n          (b = {}),\n          (e = y.xVal[0]),\n          (r = y.xVal[y.xVal.length - 1]),\n          (S = x = !1),\n          (w = 0),\n          (v = v\n            .slice()\n            .sort(function (t, e) {\n              return t - e;\n            })\n            .filter(function (t) {\n              return !this[t] && (this[t] = !0);\n            }, {}))[0] !== e && (v.unshift(e), (x = !0)),\n          v[v.length - 1] !== r && (v.push(r), (S = !0)),\n          v.forEach(function (t, e) {\n            var r,\n              n,\n              i,\n              o,\n              s,\n              a,\n              l,\n              u,\n              c,\n              p,\n              f = t,\n              d = v[e + 1],\n              h = 'steps' === g;\n            if ((h && (r = y.xNumSteps[e]), r || (r = d - f), !1 !== f))\n              for (\n                void 0 === d && (d = f), r = Math.max(r, 1e-7), n = f;\n                n <= d;\n                n = (n + r).toFixed(7) / 1\n              ) {\n                for (\n                  u = (s = (o = y.toStepping(n)) - w) / m,\n                    p = s / (c = Math.round(u)),\n                    i = 1;\n                  i <= c;\n                  i += 1\n                )\n                  b[(a = w + i * p).toFixed(5)] = [y.fromStepping(a), 0];\n                (l = -1 < v.indexOf(n) ? k : h ? U : N),\n                  !e && x && n !== d && (l = 0),\n                  (n === d && S) || (b[o.toFixed(5)] = [n, l]),\n                  (w = o);\n              }\n          }),\n          b),\n        l = t.format || { to: Math.round };\n      return (c = h.appendChild(j(a, o, l)));\n    }\n    function T() {\n      var t = l.getBoundingClientRect(),\n        e = 'offset' + ['Width', 'Height'][b.ort];\n      return 0 === b.ort ? t.width || l[e] : t.height || l[e];\n    }\n    function B(n, i, o, s) {\n      var e = function (t) {\n          return (\n            !!(t = (function (t, e, r) {\n              var n,\n                i,\n                o = 0 === t.type.indexOf('touch'),\n                s = 0 === t.type.indexOf('mouse'),\n                a = 0 === t.type.indexOf('pointer');\n              0 === t.type.indexOf('MSPointer') && (a = !0);\n              if (o) {\n                var l = function (t) {\n                  return (\n                    t.target === r ||\n                    r.contains(t.target) ||\n                    (t.target.shadowRoot && t.target.shadowRoot.contains(r))\n                  );\n                };\n                if ('touchstart' === t.type) {\n                  var u = Array.prototype.filter.call(t.touches, l);\n                  if (1 < u.length) return !1;\n                  (n = u[0].pageX), (i = u[0].pageY);\n                } else {\n                  var c = Array.prototype.find.call(t.changedTouches, l);\n                  if (!c) return !1;\n                  (n = c.pageX), (i = c.pageY);\n                }\n              }\n              (e = e || gt(w)),\n                (s || a) && ((n = t.clientX + e.x), (i = t.clientY + e.y));\n              return (t.pageOffset = e), (t.points = [n, i]), (t.cursor = s || a), t;\n            })(t, s.pageOffset, s.target || i)) &&\n            !(O() && !s.doNotReject) &&\n            ((e = h),\n            (r = b.cssClasses.tap),\n            !(\n              (e.classList\n                ? e.classList.contains(r)\n                : new RegExp('\\\\b' + r + '\\\\b').test(e.className)) && !s.doNotReject\n            ) &&\n              !(n === f.start && void 0 !== t.buttons && 1 < t.buttons) &&\n              (!s.hover || !t.buttons) &&\n              (d || t.preventDefault(), (t.calcPoint = t.points[b.ort]), void o(t, s)))\n          );\n          var e, r;\n        },\n        r = [];\n      return (\n        n.split(' ').forEach(function (t) {\n          i.addEventListener(t, e, !!d && { passive: !0 }), r.push([t, e]);\n        }),\n        r\n      );\n    }\n    function q(t) {\n      var e,\n        r,\n        n,\n        i,\n        o,\n        s,\n        a =\n          (100 *\n            (t -\n              ((e = l),\n              (r = b.ort),\n              (n = e.getBoundingClientRect()),\n              (i = e.ownerDocument),\n              (o = i.documentElement),\n              (s = gt(i)),\n              /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (s.x = 0),\n              r ? n.top + s.y - o.clientTop : n.left + s.x - o.clientLeft))) /\n          T();\n      return (a = ft(a)), b.dir ? 100 - a : a;\n    }\n    function X(t, e) {\n      'mouseout' === t.type &&\n        'HTML' === t.target.nodeName &&\n        null === t.relatedTarget &&\n        _(t, e);\n    }\n    function Y(t, e) {\n      if (\n        -1 === navigator.appVersion.indexOf('MSIE 9') &&\n        0 === t.buttons &&\n        0 !== e.buttonsProperty\n      )\n        return _(t, e);\n      var r = (b.dir ? -1 : 1) * (t.calcPoint - e.startCalcPoint);\n      Z(0 < r, (100 * r) / e.baseSize, e.locations, e.handleNumbers);\n    }\n    function _(t, e) {\n      e.handle && (mt(e.handle, b.cssClasses.active), (g -= 1)),\n        e.listeners.forEach(function (t) {\n          E.removeEventListener(t[0], t[1]);\n        }),\n        0 === g &&\n          (mt(h, b.cssClasses.drag),\n          et(),\n          t.cursor && ((C.style.cursor = ''), C.removeEventListener('selectstart', ct))),\n        e.handleNumbers.forEach(function (t) {\n          J('change', t), J('set', t), J('end', t);\n        });\n    }\n    function I(t, e) {\n      if (e.handleNumbers.some(L)) return !1;\n      var r;\n      1 === e.handleNumbers.length &&\n        ((r = u[e.handleNumbers[0]].children[0]), (g += 1), ht(r, b.cssClasses.active));\n      t.stopPropagation();\n      var n = [],\n        i = B(f.move, E, Y, {\n          target: t.target,\n          handle: r,\n          listeners: n,\n          startCalcPoint: t.calcPoint,\n          baseSize: T(),\n          pageOffset: t.pageOffset,\n          handleNumbers: e.handleNumbers,\n          buttonsProperty: t.buttons,\n          locations: S.slice(),\n        }),\n        o = B(f.end, E, _, {\n          target: t.target,\n          handle: r,\n          listeners: n,\n          doNotReject: !0,\n          handleNumbers: e.handleNumbers,\n        }),\n        s = B('mouseout', E, X, {\n          target: t.target,\n          handle: r,\n          listeners: n,\n          doNotReject: !0,\n          handleNumbers: e.handleNumbers,\n        });\n      n.push.apply(n, i.concat(o, s)),\n        t.cursor &&\n          ((C.style.cursor = getComputedStyle(t.target).cursor),\n          1 < u.length && ht(h, b.cssClasses.drag),\n          C.addEventListener('selectstart', ct, !1)),\n        e.handleNumbers.forEach(function (t) {\n          J('start', t);\n        });\n    }\n    function n(t) {\n      if (!t.buttons && !t.touches) return !1;\n      t.stopPropagation();\n      var i,\n        o,\n        s,\n        e = q(t.calcPoint),\n        r =\n          ((i = e),\n          (s = !(o = 100)),\n          u.forEach(function (t, e) {\n            if (!L(e)) {\n              var r = S[e],\n                n = Math.abs(r - i);\n              (n < o || (n <= o && r < i) || (100 === n && 100 === o)) &&\n                ((s = e), (o = n));\n            }\n          }),\n          s);\n      if (!1 === r) return !1;\n      b.events.snap || pt(h, b.cssClasses.tap, b.animationDuration),\n        rt(r, e, !0, !0),\n        et(),\n        J('slide', r, !0),\n        J('update', r, !0),\n        J('change', r, !0),\n        J('set', r, !0),\n        b.events.snap && I(t, { handleNumbers: [r] });\n    }\n    function W(t) {\n      var e = q(t.calcPoint),\n        r = y.getStep(e),\n        n = y.fromStepping(r);\n      Object.keys(v).forEach(function (t) {\n        'hover' === t.split('.')[0] &&\n          v[t].forEach(function (t) {\n            t.call(a, n);\n          });\n      });\n    }\n    function $(t, e) {\n      (v[t] = v[t] || []),\n        v[t].push(e),\n        'update' === t.split('.')[0] &&\n          u.forEach(function (t, e) {\n            J('update', e);\n          });\n    }\n    function G(t) {\n      var n = t && t.split('.')[0],\n        i = n && t.substring(n.length);\n      Object.keys(v).forEach(function (t) {\n        var e = t.split('.')[0],\n          r = t.substring(e.length);\n        (n && n !== e) || (i && i !== r) || delete v[t];\n      });\n    }\n    function J(r, n, i) {\n      Object.keys(v).forEach(function (t) {\n        var e = t.split('.')[0];\n        r === e &&\n          v[t].forEach(function (t) {\n            t.call(a, x.map(b.format.to), n, x.slice(), i || !1, S.slice(), a);\n          });\n      });\n    }\n    function K(t, e, r, n, i, o) {\n      var s;\n      return (\n        1 < u.length &&\n          !b.events.unconstrained &&\n          (n &&\n            0 < e &&\n            ((s = y.getAbsoluteDistance(t[e - 1], b.margin, 0)), (r = Math.max(r, s))),\n          i &&\n            e < u.length - 1 &&\n            ((s = y.getAbsoluteDistance(t[e + 1], b.margin, 1)), (r = Math.min(r, s)))),\n        1 < u.length &&\n          b.limit &&\n          (n &&\n            0 < e &&\n            ((s = y.getAbsoluteDistance(t[e - 1], b.limit, 0)), (r = Math.min(r, s))),\n          i &&\n            e < u.length - 1 &&\n            ((s = y.getAbsoluteDistance(t[e + 1], b.limit, 1)), (r = Math.max(r, s)))),\n        b.padding &&\n          (0 === e &&\n            ((s = y.getAbsoluteDistance(0, b.padding[0], 0)), (r = Math.max(r, s))),\n          e === u.length - 1 &&\n            ((s = y.getAbsoluteDistance(100, b.padding[1], 1)), (r = Math.min(r, s)))),\n        !((r = ft((r = y.getStep(r)))) === t[e] && !o) && r\n      );\n    }\n    function Q(t, e) {\n      var r = b.ort;\n      return (r ? e : t) + ', ' + (r ? t : e);\n    }\n    function Z(t, n, r, e) {\n      var i = r.slice(),\n        o = [!t, t],\n        s = [t, !t];\n      (e = e.slice()),\n        t && e.reverse(),\n        1 < e.length\n          ? e.forEach(function (t, e) {\n              var r = K(i, t, i[t] + n, o[e], s[e], !1);\n              !1 === r ? (n = 0) : ((n = r - i[t]), (i[t] = r));\n            })\n          : (o = s = [!0]);\n      var a = !1;\n      e.forEach(function (t, e) {\n        a = rt(t, r[t] + n, o[e], s[e]) || a;\n      }),\n        a &&\n          e.forEach(function (t) {\n            J('update', t), J('slide', t);\n          });\n    }\n    function tt(t, e) {\n      return b.dir ? 100 - t - e : t;\n    }\n    function et() {\n      m.forEach(function (t) {\n        var e = 50 < S[t] ? -1 : 1,\n          r = 3 + (u.length + e * t);\n        u[t].style.zIndex = r;\n      });\n    }\n    function rt(t, e, r, n) {\n      return (\n        !1 !== (e = K(S, t, e, r, n, !1)) &&\n        ((function (t, e) {\n          (S[t] = e), (x[t] = y.fromStepping(e));\n          var r = 'translate(' + Q(10 * (tt(e, 0) - A) + '%', '0') + ')';\n          (u[t].style[b.transformRule] = r), nt(t), nt(t + 1);\n        })(t, e),\n        !0)\n      );\n    }\n    function nt(t) {\n      if (s[t]) {\n        var e = 0,\n          r = 100;\n        0 !== t && (e = S[t - 1]), t !== s.length - 1 && (r = S[t]);\n        var n = r - e,\n          i = 'translate(' + Q(tt(e, n) + '%', '0') + ')',\n          o = 'scale(' + Q(n / 100, '1') + ')';\n        s[t].style[b.transformRule] = i + ' ' + o;\n      }\n    }\n    function it(t, e) {\n      return null === t || !1 === t || void 0 === t\n        ? S[e]\n        : ('number' == typeof t && (t = String(t)),\n          (t = b.format.from(t)),\n          !1 === (t = y.toStepping(t)) || isNaN(t) ? S[e] : t);\n    }\n    function ot(t, e) {\n      var r = dt(t),\n        n = void 0 === S[0];\n      (e = void 0 === e || !!e),\n        b.animate && !n && pt(h, b.cssClasses.tap, b.animationDuration),\n        m.forEach(function (t) {\n          rt(t, it(r[t], t), !0, !1);\n        });\n      for (var i = 1 === m.length ? 0 : 1; i < m.length; ++i)\n        m.forEach(function (t) {\n          rt(t, S[t], !0, !0);\n        });\n      et(),\n        m.forEach(function (t) {\n          J('update', t), null !== r[t] && e && J('set', t);\n        });\n    }\n    function st() {\n      var t = x.map(b.format.to);\n      return 1 === t.length ? t[0] : t;\n    }\n    function at(t) {\n      var e = S[t],\n        r = y.getNearbySteps(e),\n        n = x[t],\n        i = r.thisStep.step,\n        o = null;\n      if (b.snap)\n        return [n - r.stepBefore.startValue || null, r.stepAfter.startValue - n || null];\n      !1 !== i && n + i > r.stepAfter.startValue && (i = r.stepAfter.startValue - n),\n        (o =\n          n > r.thisStep.startValue\n            ? r.thisStep.step\n            : !1 !== r.stepBefore.step && n - r.stepBefore.highestStep),\n        100 === e ? (i = null) : 0 === e && (o = null);\n      var s = y.countStepDecimals();\n      return (\n        null !== i && !1 !== i && (i = Number(i.toFixed(s))),\n        null !== o && !1 !== o && (o = Number(o.toFixed(s))),\n        [o, i]\n      );\n    }\n    return (\n      ht((e = h), b.cssClasses.target),\n      0 === b.dir ? ht(e, b.cssClasses.ltr) : ht(e, b.cssClasses.rtl),\n      0 === b.ort ? ht(e, b.cssClasses.horizontal) : ht(e, b.cssClasses.vertical),\n      ht(\n        e,\n        'rtl' === getComputedStyle(e).direction\n          ? b.cssClasses.textDirectionRtl\n          : b.cssClasses.textDirectionLtr,\n      ),\n      (l = V(e, b.cssClasses.base)),\n      (function (t, e) {\n        var r = V(e, b.cssClasses.connects);\n        (u = []), (s = []).push(M(r, t[0]));\n        for (var n = 0; n < b.handles; n++)\n          u.push(D(e, n)), (m[n] = n), s.push(M(r, t[n + 1]));\n      })(b.connect, l),\n      (p = b.events).fixed ||\n        u.forEach(function (t, e) {\n          B(f.start, t.children[0], I, { handleNumbers: [e] });\n        }),\n      p.tap && B(f.start, l, n, {}),\n      p.hover && B(f.move, l, W, { hover: !0 }),\n      p.drag &&\n        s.forEach(function (t, e) {\n          if (!1 !== t && 0 !== e && e !== s.length - 1) {\n            var r = u[e - 1],\n              n = u[e],\n              i = [t];\n            ht(t, b.cssClasses.draggable),\n              p.fixed && (i.push(r.children[0]), i.push(n.children[0])),\n              i.forEach(function (t) {\n                B(f.start, t, I, { handles: [r, n], handleNumbers: [e - 1, e] });\n              });\n          }\n        }),\n      ot(b.start),\n      b.pips && R(b.pips),\n      b.tooltips && H(),\n      $('update', function (t, e, s, r, a) {\n        m.forEach(function (t) {\n          var e = u[t],\n            r = K(S, t, 0, !0, !0, !0),\n            n = K(S, t, 100, !0, !0, !0),\n            i = a[t],\n            o = b.ariaFormat.to(s[t]);\n          (r = y.fromStepping(r).toFixed(1)),\n            (n = y.fromStepping(n).toFixed(1)),\n            (i = y.fromStepping(i).toFixed(1)),\n            e.children[0].setAttribute('aria-valuemin', r),\n            e.children[0].setAttribute('aria-valuemax', n),\n            e.children[0].setAttribute('aria-valuenow', i),\n            e.children[0].setAttribute('aria-valuetext', o);\n        });\n      }),\n      (a = {\n        destroy: function () {\n          for (var t in b.cssClasses)\n            b.cssClasses.hasOwnProperty(t) && mt(h, b.cssClasses[t]);\n          for (; h.firstChild; ) h.removeChild(h.firstChild);\n          delete h.noUiSlider;\n        },\n        steps: function () {\n          return m.map(at);\n        },\n        on: $,\n        off: G,\n        get: st,\n        set: ot,\n        setHandle: function (t, e, r) {\n          if (!(0 <= (t = Number(t)) && t < m.length))\n            throw new Error('noUiSlider (' + lt + '): invalid handle number, got: ' + t);\n          rt(t, it(e, t), !0, !0), J('update', t), r && J('set', t);\n        },\n        reset: function (t) {\n          ot(b.start, t);\n        },\n        __moveHandles: function (t, e, r) {\n          Z(t, e, S, r);\n        },\n        options: o,\n        updateOptions: function (e, t) {\n          var r = st(),\n            n = [\n              'margin',\n              'limit',\n              'padding',\n              'range',\n              'animate',\n              'snap',\n              'step',\n              'format',\n              'pips',\n              'tooltips',\n            ];\n          n.forEach(function (t) {\n            void 0 !== e[t] && (o[t] = e[t]);\n          });\n          var i = vt(o);\n          n.forEach(function (t) {\n            void 0 !== e[t] && (b[t] = i[t]);\n          }),\n            (y = i.spectrum),\n            (b.margin = i.margin),\n            (b.limit = i.limit),\n            (b.padding = i.padding),\n            b.pips ? R(b.pips) : F(),\n            b.tooltips ? H() : z(),\n            (S = []),\n            ot(e.start || r, t);\n        },\n        target: h,\n        removePips: F,\n        removeTooltips: z,\n        getTooltips: function () {\n          return i;\n        },\n        getOrigins: function () {\n          return u;\n        },\n        pips: R,\n      })\n    );\n  }\n  return {\n    __spectrum: i,\n    version: lt,\n    cssClasses: d,\n    create: function (t, e) {\n      if (!t || !t.nodeName)\n        throw new Error(\n          'noUiSlider (' + lt + '): create requires a single element, got: ' + t,\n        );\n      if (t.noUiSlider)\n        throw new Error('noUiSlider (' + lt + '): Slider was already initialized.');\n      var r = j(t, vt(e), e);\n      return (t.noUiSlider = r);\n    },\n  };\n});\n\n\n//# sourceURL=webpack://calculator/./node_modules/svelte-materialify/dist/components/Slider/nouislider.min.js?");

/***/ })

}]);